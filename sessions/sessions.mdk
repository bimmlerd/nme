Title         : Numerik Exercise Sessions
Heading Base  : 2
Logo          : false
Package       : mathtools

[TITLE]

~ MathDefs
\newcommand{\M}[1]{\mathbf{#1}}
\newcommand{\A}{\M{A}}
\newcommand{\I}{\M{I}}
~

# First Session

## Organisation

abohn@student.ethz.ch

## Much Blah about Householder reflections (see also email)

# Second Session

## Organisation

Midterm information -> Hiptmair, G Alberti or F Leonardi

## Assignment 1 Post

### Arten von Fehlern

- __Näherungsfehler__: Vereinfachte Annahmen $\to$ simplere/schnellere Berechnung
- __Diskretisierungsfehler__: Iterative Verfahren $\to$ endliche Anzahl Schritte im Computer (unendlich wäre exakte Lösung), deshalb Näherung $\neq$ exakter Wert. Beispiel: Newton-Verfahren
- __Rundungsfehler__: Korrekte Zahl wird auf nächste Computerzahl auf- oder abgerundet. Fehler $\to$ Numerische Instabilität $\to$ falsches Ergebnis

### Tipps für Cancellation Aufgaben

- Nie zwei fast gleich grosse Werte subtrahieren
- Nie einen sehr grossen mit/von einem sehr kleinen Wert addieren/subtrahieren $\to$ versuchen in Multiplikation umzuwandeln

## Assignment 2 Pre

### Lyapunov Equation

Normales LGS: $\A x = b$

Lyapunov-Gleichung: $\M{AX}+\M{XA}^T = \I$

#### f) Upper bound for `nnz(C)`

`nnz(`$\M{X}$`)` $\approx O(n) \to \M{X}$ ist sparse

Finde: nnz(C) <= * $\cdot$ nnz(A)

Tipps: Betrachte Blöcke von C (a11 * B etc)
Fallunterscheidung i != j, i = j $\to$ Lösung

Ist C immer eine Sparse Matrix? Nein. Bedingung nnz(C) $\approx$ O(n)

#### g) Eigen implementation

- Sparse -> Triplets
- unsupported library path to include -> Kroenecker Product

``` cpp
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <iostream>
#include <vector>

using namespace Eigen;

SparseMatrix<double> buildC(const MatrixXd &A) {
  int n = A.rows();
  SparseMatrix<double> C(n*n, n*n);
  
  vector<Triplet<double>> triplets;
  MatrixXd I = MatrixXd::Identity(n,n);
  
  // nested for loop through blocks of kronecker product
    // Besetze Triplet (filter out 0s, no need to save those in sparse)
    Triplet<double> triplet = Triplet(row, column, value); // row col from loops, val from kron prod
    triplets.push_back(triplet);
  
  C.setFromTriplets(triplets.begin, triplets.end);
  C.makeCompressed();
  return C
}
```

#### i) solveLyapunov

``` cpp
  int n = A.rows();
  SparseMatrix<double> C;
  
  C = buildC(A);
  b = // Eigen::Map<MatrixXd> from Identity
  // Löse Cx = b (x als Vektor)
  VectorXd vecX(n*n);
  SparseLU<SparseMatrix<double>> solver;
  solver.compute(C);
  vecX = solver.solve(b);
  // Map vecX zu X
```

### Partioned Matrix

$\A = \begin{bmatrix}
\M{R} & v \\
u^T & 0
\end{bmatrix}$

#### a) Wann ist R invertierbar?
$\det(\M{R}) \neq 0$

#### b)
$\begin{bmatrix}
\M{R} & v \\
u^T & 0
\end{bmatrix}
\begin{bmatrix}
z\\
\chi
\end{bmatrix} = 
\begin{bmatrix}
b \\
\Beta
\end{bmatrix}$

$\begin{bmatrix}
\I & 0 \\
0 & 1
\end{bmatrix}$