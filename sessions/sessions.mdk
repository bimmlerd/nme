Title         : Numerik Exercise Sessions
Heading Base  : 2
Logo          : false
Package       : mathtools

[TITLE]

~ MathDefs
\newcommand{\M}[1]{\mathbf{#1}}
\newcommand{\A}{\M{A}}
\newcommand{\I}{\M{I}}
\newcommand{\x}{\M{x}}
\newcommand{\Ax}{\A\x}
~

# Session

## Organisation

abohn@student.ethz.ch

## Much Blah about Householder reflections (see also email)

# Session

## Organisation

Midterm information -> Hiptmair, G Alberti or F Leonardi

## Assignment 1 Post

### Arten von Fehlern

- __Näherungsfehler__: Vereinfachte Annahmen $\to$ simplere/schnellere Berechnung
- __Diskretisierungsfehler__: Iterative Verfahren $\to$ endliche Anzahl Schritte im Computer (unendlich wäre exakte Lösung), deshalb Näherung $\neq$ exakter Wert. Beispiel: Newton-Verfahren
- __Rundungsfehler__: Korrekte Zahl wird auf nächste Computerzahl auf- oder abgerundet. Fehler $\to$ Numerische Instabilität $\to$ falsches Ergebnis

### Tipps für Cancellation Aufgaben

- Nie zwei fast gleich grosse Werte subtrahieren
- Nie einen sehr grossen mit/von einem sehr kleinen Wert addieren/subtrahieren $\to$ versuchen in Multiplikation umzuwandeln

## Assignment 2 Pre

### Lyapunov Equation

Normales LGS: $\A x = b$

Lyapunov-Gleichung: $\M{AX}+\M{XA}^T = \I$

#### f) Upper bound for `nnz(C)`

`nnz(`$\M{X}$`)` $\approx O(n) \to \M{X}$ ist sparse

Finde: nnz(C) <= * $\cdot$ nnz(A)

Tipps: Betrachte Blöcke von C (a11 * B etc)
Fallunterscheidung i != j, i = j $\to$ Lösung

Ist C immer eine Sparse Matrix? Nein. Bedingung nnz(C) $\approx$ O(n)

#### g) Eigen implementation

- Sparse -> Triplets
- unsupported library path to include -> Kroenecker Product

``` cpp
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <iostream>
#include <vector>

using namespace Eigen;

SparseMatrix<double> buildC(const MatrixXd &A) {
  int n = A.rows();
  SparseMatrix<double> C(n*n, n*n);
  
  vector<Triplet<double>> triplets;
  MatrixXd I = MatrixXd::Identity(n,n);
  
  // nested for loop through blocks of kronecker product
    // Besetze Triplet (filter out 0s, no need to save those in sparse)
    Triplet<double> triplet = Triplet(row, column, value); // row col from loops, val from kron prod
    triplets.push_back(triplet);
  
  C.setFromTriplets(triplets.begin, triplets.end);
  C.makeCompressed();
  return C
}
```

#### i) solveLyapunov

``` cpp
  int n = A.rows();
  SparseMatrix<double> C;
  
  C = buildC(A);
  b = // Eigen::Map<MatrixXd> from Identity
  // Löse Cx = b (x als Vektor)
  VectorXd vecX(n*n);
  SparseLU<SparseMatrix<double>> solver;
  solver.compute(C);
  vecX = solver.solve(b);
  // Map vecX zu X
```

### Partioned Matrix

$\A = \begin{bmatrix}
\M{R} & v \\
u^T & 0
\end{bmatrix}$

#### a) Wann ist R invertierbar?
$\det(\M{R}) \neq 0$

#### b)
$\begin{bmatrix}
\M{R} & v \\
u^T & 0
\end{bmatrix}
\begin{bmatrix}
z\\
\chi
\end{bmatrix} = 
\begin{bmatrix}
b \\
\beta
\end{bmatrix}$

$\begin{bmatrix}
\I & 0 \\
0 & 1
\end{bmatrix}$

# Session

## Pre

### Rank one perturbation

_Theorem_ (3.1.6.103)

_LGS_ $\Ax = \M{b}$ $\A \in \mathbb{M}^{n\times n}$ regulär

_Störung_ $A$ mit Tilde drüber: veränderung von $\A$ in einem einzelnen Eintrag/ einer einzelnen Zeile von A heissen Rang-1-Modifikationen

_Konstruktion_

$\tilde{A} := A + u*v^H$ ($u*v^H$ Matrix von Rang 1)

_Idee_

$\tilde{A}\tilde{x} = b$

Schreib als

~ Equation
\begin{bmatrix}
\A & u \\
v^H & -1
\end{bmatrix}
\cdot
\begin{bmatrix}
\tilde{x} \\
\tilde{\xi}
\end{bmatrix}
=
\begin{bmatrix}
b \\
0
\end{bmatrix}
~

~ Math
\begin{bmatrix}
\A \tilde{x} + u \tilde{\xi} \\
v^H \tilde{x} - \tilde{\xi}
\end{bmatrix}
=
\begin{bmatrix}
b \\
0
\end{bmatrix}
~

~ Math
\tilde{\xi} = v^{H}\tilde{x}
~


~ Math
\tilde{A}\tilde{\xi} + u \times \tilde{\xi} = A\tilde{x} + uv^H\tilde{x} = (A + uv^{H}) \tilde{x} = b
~

------

Was macht Code?

d -> Vektor, tol -> Toleranz

a) übersetzen

```
Matlab: lnew = min(abs(d))
```
```cpp
C++: double lnew = d.cwiseAbs().minCoeff()
```

c) Ziel: optimale Komplexität

Benutze SMW-Formel um modifiziertes LGS zu lösen ~1.6.113 im Skript

### not a core problem

### 3. C++ Kentnisse verbessern

Unterpunkte _müssen_ nicht beachtet werden

Aufgabe: Umwandlung von Triples (COO format) zu CRS (compact row storage)

_Theorie_ Triplet List format Skript 1.7.6
Triplets (row, col, value) siehe Serie 2

_Eigenschaften_

- Indizes können doppelt vorkommen -> Eintrag in Matrix ist Summe der einzelnen Values mit selben indizes
- reihenfolge im vector egal
- insgesamt gleiche anzahl werte von row, col, val

_CRS Compact Row Storage_

Es git 3 arrays:

- val = Array mit allen werten ungleich 0
- col_ind = zu jedem element aus val index der spalte 
- row_ptr = welche werte von val zu welcher zeile (rowptr[n+1] = nnz(A)+1)


